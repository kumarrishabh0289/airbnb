{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (b.hasOwnProperty(p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) {\n        if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nimport * as React from 'react';\nimport { registerForLocalization, provideLocalizationService } from '@progress/kendo-react-intl';\nimport { messages, date, time, dateTimePickerCancel as cancel, dateTimePickerSet as set } from '../messages';\nimport { Button, ButtonGroup } from '@progress/kendo-react-buttons';\nimport { Calendar } from '../calendar/components/Calendar';\nimport { TimePart } from '../timepicker/TimePart';\nimport { setTime, getToday, MIN_TIME, MAX_TIME } from '../utils';\nimport { isEqualDate } from '@progress/kendo-date-math';\nimport { Keys, classNames } from '@progress/kendo-react-common';\nimport { MIDNIGHT_DATE } from '../defaults';\nimport { getNow } from '../timepicker/utils';\n/**\n * @hidden\n */\n\nvar DateTimeSelector =\n/** @class */\nfunction (_super) {\n  __extends(DateTimeSelector, _super);\n\n  function DateTimeSelector(props) {\n    var _this = _super.call(this, props) || this;\n\n    _this.focus = function (args) {\n      // Async to avoid stealing the focus from the DateInput on close\n      Promise.resolve().then(function () {\n        if (_this.state.tab === 'time' && _this._timePart) {\n          _this._timePart.focus(args);\n        }\n\n        if (_this.state.tab === 'date' && _this._calendar && _this._calendar.element) {\n          _this._calendar.element.focus(args);\n        }\n      });\n    };\n\n    _this.move = function (direction) {\n      if (direction === 'right' && _this.state.tab === 'time') {\n        return;\n      }\n\n      if (direction === 'left' && _this.state.tab === 'date') {\n        return;\n      }\n\n      var nextPart = direction === 'left' ? 'date' : 'time';\n      _this.shouldFocusPart = true;\n\n      _this.setState({\n        tab: nextPart\n      });\n    };\n\n    _this.handleReject = function (event) {\n      _this.setState({\n        dateValue: _this.props.value,\n        timeValue: _this.props.value || MIDNIGHT_DATE\n      });\n\n      var value = _this.mergeDate(_this.props.value, _this.props.value || MIDNIGHT_DATE);\n\n      if (_this.props.onReject) {\n        var args = {\n          nativeEvent: event.nativeEvent,\n          syntheticEvent: event,\n          target: _this,\n          value: value\n        };\n\n        _this.props.onReject.call(undefined, args);\n      }\n    };\n\n    _this.handleAccept = function (event, timeOverride) {\n      if (!_this.state.dateValue || !_this.state.timeValue || !_this.hasDateValue) {\n        return;\n      }\n\n      var value = _this.mergeDate(_this.state.dateValue, timeOverride || _this.state.timeValue);\n\n      _this.props.onChange.call(undefined, {\n        syntheticEvent: event,\n        nativeEvent: event.nativeEvent,\n        value: value,\n        target: _this\n      });\n    };\n\n    _this.handleNowClick = function (event) {\n      _this.setState({\n        timeValue: getNow()\n      });\n\n      _this.handleAccept(event, getNow());\n    };\n\n    _this.handleCalendarValueChange = function (event) {\n      event.syntheticEvent.stopPropagation();\n\n      _this.setState({\n        dateValue: event.value,\n        tab: 'time'\n      });\n\n      _this.shouldFocusPart = true;\n    };\n\n    _this.handleTimeListContainerChange = function (candidate) {\n      _this.setState({\n        timeValue: candidate\n      });\n    };\n\n    _this.handleDateClick = function (event) {\n      event.stopPropagation();\n\n      _this.move('left');\n    };\n\n    _this.handleTimeClick = function (event) {\n      event.stopPropagation();\n\n      _this.move('right');\n    };\n\n    _this.handleKeyDown = function (event) {\n      var keyCode = event.keyCode,\n          altKey = event.altKey;\n\n      switch (keyCode) {\n        case Keys.enter:\n          if (!_this.hasActiveButton() && _this.hasDateValue) {\n            _this.handleAccept(event);\n          }\n\n          return;\n\n        case Keys.left:\n          if (!altKey) {\n            return;\n          }\n\n          _this.move('left');\n\n          return;\n\n        case Keys.right:\n          if (!altKey) {\n            return;\n          }\n\n          _this.move('right');\n\n          return;\n\n        default:\n          return;\n      }\n    };\n\n    _this.handleTimePartMount = function (value) {\n      _this.setState({\n        timeValue: value\n      });\n    };\n\n    _this.state = {\n      tab: 'date',\n      dateValue: _this.props.value,\n      timeValue: _this.props.value || MIDNIGHT_DATE\n    };\n    return _this;\n  }\n\n  Object.defineProperty(DateTimeSelector.prototype, \"calendar\", {\n    get: function get() {\n      return this._calendar;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(DateTimeSelector.prototype, \"timePart\", {\n    get: function get() {\n      return this._timePart;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(DateTimeSelector.prototype, \"hasDateValue\", {\n    get: function get() {\n      return this.state.dateValue !== null;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  DateTimeSelector.prototype.componentDidUpdate = function () {\n    if (this.shouldFocusPart) {\n      this.focus({\n        preventScroll: true\n      });\n    }\n\n    this.shouldFocusPart = false;\n  };\n\n  DateTimeSelector.prototype.render = function () {\n    var _this = this;\n\n    var _a = this.props,\n        disabled = _a.disabled,\n        cancelButton = _a.cancelButton,\n        min = _a.min,\n        max = _a.max,\n        weekNumber = _a.weekNumber,\n        focusedDate = _a.focusedDate,\n        format = _a.format;\n    var rootClassName = classNames({\n      'k-date-tab': this.state.tab === 'date',\n      'k-time-tab': this.state.tab === 'time',\n      'k-state-disabled': disabled\n    }, 'k-datetime-wrap');\n    var setButtonClassName = classNames({\n      'k-state-disabled': !this.hasDateValue\n    }, 'k-time-accept k-button k-primary');\n    var localizationService = provideLocalizationService(this);\n    var dateMessage = localizationService.toLanguageString(date, messages[date]);\n    var timeMessage = localizationService.toLanguageString(time, messages[time]);\n    var cancelMessage = localizationService.toLanguageString(cancel, messages[cancel]);\n    var setMessage = localizationService.toLanguageString(set, messages[set]);\n    return React.createElement(\"div\", {\n      onKeyDown: this.handleKeyDown,\n      className: rootClassName,\n      tabIndex: -1\n    }, React.createElement(\"div\", {\n      className: \"k-datetime-buttongroup\"\n    }, React.createElement(ButtonGroup, {\n      width: \"100%\"\n    }, React.createElement(Button, {\n      selected: this.state.tab === 'date',\n      togglable: true,\n      onClick: this.handleDateClick\n    }, dateMessage), React.createElement(Button, {\n      selected: this.state.tab === 'time',\n      togglable: true,\n      onClick: this.handleTimeClick\n    }, timeMessage))), React.createElement(\"div\", {\n      className: \"k-datetime-selector\"\n    }, React.createElement(\"div\", {\n      className: \"k-datetime-calendar-wrap\"\n    }, React.createElement(Calendar, {\n      key: 0,\n      disabled: disabled || this.state.tab !== 'date',\n      ref: function ref(calendar) {\n        _this._calendar = calendar;\n      },\n      value: this.state.dateValue,\n      min: min,\n      max: max,\n      weekNumber: weekNumber,\n      focusedDate: focusedDate,\n      onChange: this.handleCalendarValueChange,\n      navigation: false\n    })), React.createElement(\"div\", {\n      className: \"k-datetime-time-wrap\"\n    }, React.createElement(TimePart, {\n      key: 1,\n      onNowClick: this.handleNowClick,\n      disabled: disabled || this.state.tab !== 'time',\n      ref: function ref(timePart) {\n        _this._timePart = timePart;\n      },\n      min: this.minTime || MIN_TIME,\n      max: this.maxTime || MAX_TIME,\n      value: this.state.timeValue,\n      format: format,\n      onChange: this.handleTimeListContainerChange,\n      onMount: this.handleTimePartMount\n    }))), React.createElement(\"div\", {\n      className: \"k-datetime-footer k-action-buttons\"\n    }, cancelButton && React.createElement(\"button\", __assign({\n      ref: function ref(btn) {\n        _this._cancelButton = btn;\n      },\n      className: \"k-button k-time-cancel\",\n      onClick: this.handleReject,\n      title: cancelMessage\n    }, {\n      'aria-label': cancelMessage\n    }), cancelMessage), React.createElement(\"button\", __assign({\n      ref: function ref(btn) {\n        _this._acceptButton = btn;\n      },\n      className: setButtonClassName,\n      onClick: this.handleAccept,\n      title: setMessage\n    }, {\n      'aria-label': setMessage\n    }), setMessage)));\n  };\n\n  Object.defineProperty(DateTimeSelector.prototype, \"minTime\", {\n    get: function get() {\n      return this.props.minTime !== undefined ? this.props.minTime : this.normalizeRange(this.props.min, this.state.dateValue);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(DateTimeSelector.prototype, \"maxTime\", {\n    get: function get() {\n      return this.props.maxTime !== undefined ? this.props.maxTime : this.normalizeRange(this.props.max, this.state.dateValue);\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  DateTimeSelector.prototype.normalizeRange = function (candidate, value) {\n    return isEqualDate(candidate, value || getToday()) ? candidate : null;\n  };\n\n  DateTimeSelector.prototype.hasActiveButton = function () {\n    if (!this._acceptButton) {\n      return false;\n    }\n\n    return document.activeElement === this._acceptButton || document.activeElement === this._cancelButton;\n  };\n\n  DateTimeSelector.prototype.mergeTime = function (current, candidate) {\n    return current && candidate ? setTime(candidate, current) : candidate;\n  };\n\n  DateTimeSelector.prototype.mergeDate = function (candidate, value) {\n    return candidate ? setTime(candidate || getToday(), value) : value;\n  };\n\n  return DateTimeSelector;\n}(React.Component);\n\nexport { DateTimeSelector };\nregisterForLocalization(DateTimeSelector);","map":null,"metadata":{},"sourceType":"module"}